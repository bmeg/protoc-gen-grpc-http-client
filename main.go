package main

import (
	"bytes"
	"flag"
	"log"
	"strings"
	"text/template"

	//"github.com/golang/glog"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/proto"

	"google.golang.org/protobuf/compiler/protogen"
)

var CODE_HEADER string = `
// Code generated by protoc-gen-grpc-http-client. DO NOT EDIT.
package {{.Package}}

import (
	"io"
)

// use io module, incase generated sections don't to avoid 'import not used' error
var _ = io.EOF 

`

var CODE_SERVICE string = `
// {{.Service}}HttpClient connects to GRPC http gateway
type {{.Service}}HttpClient struct {
	server string
}

// New{{.Service}}HttpClient creates new {{.Service}}HttpClient
func New{{.Service}}HttpClient(url string) *{{.Service}}HttpClient {
	o := &{{.Service}}HttpClient{server:url}
  	return o
}

`

var CODE_METHOD string = `
func (client *{{.Service}}HttpClient) {{.Name}}(i *{{.InputType}}) (*{{.OutputType}}, error) {
	// StreamingInput: {{.StreamInput}}
	// StreamingOutput: {{.StreamOutput}}
	
	return nil, nil
}

`

func contains(c []string, a string) bool {
	for _, i := range c {
		if a == i {
			return true
		}
	}
	return false
}

type headerDesc struct {
	Package string
}

type serviceDesc struct {
	Service string
}

type methodDesc struct {
	Package      string
	Service      string
	Name         string
	InputType    string
	OutputType   string
	StreamOutput bool
	StreamInput  bool
}

func cleanProtoType(name string, p string) string {
	if strings.HasPrefix(name, "."+p+".") {
		return name[len(p)+2:]
	}
	return name
}

func boolPtrDefaultFalse(b *bool) bool {
	if b == nil {
		return false
	}
	return *b
}

func main() {
	flag.Parse()
	//defer glog.Flush()

	/*
		if *versionFlag {
			fmt.Printf("Version %v, commit %v, built at %v\n", version, commit, date)
			os.Exit(0)
		}
	*/

	protogen.Options{
		ParamFunc: flag.CommandLine.Set,
	}.Run(func(gen *protogen.Plugin) error {
		headerTemplate, _ := template.New("header").Parse(CODE_HEADER)
		serviceTemplate, _ := template.New("service").Parse(CODE_SERVICE)
		methodTemplate, _ := template.New("method").Parse(CODE_METHOD)

		for _, file := range gen.Files {

			log.Printf("ext: %#v", file.Extensions)
			if contains(gen.Request.FileToGenerate, *file.Proto.Name) {
				//log.Printf("File: %s", *file.Name)
				text := bytes.NewBufferString("")
				headerTemplate.Execute(text, headerDesc{Package: *file.Proto.Package})
				for _, service := range file.Services {
					serviceTemplate.Execute(text, serviceDesc{Service: service.GoName})
					log.Printf("Service: %s", service.GoName)
					for _, method := range service.Methods {

						httpMethod := ""
						httpPath := ""
						if proto.HasExtension(method.Desc.Options(), annotations.E_Http) {
							log.Printf("Has HTTP")
							ext := proto.GetExtension(method.Desc.Options(), annotations.E_Http)
							opts, ok := ext.(*annotations.HttpRule)
							if !ok {
								//return nil, fmt.Errorf("extension is %T; want an HttpRule", ext)
							} else {
								if p, ok := opts.Pattern.(*annotations.HttpRule_Get); ok {
									httpMethod = "GET"
									httpPath = p.Get
								} else {
									log.Printf("http: %#v", opts.Pattern)
								}
							}
						}

						log.Printf(" method: %#v", method.Desc.Options().ProtoReflect().ProtoMethods())
						err := methodTemplate.Execute(text, methodDesc{
							Package: *file.Proto.Package,
							Service: service.GoName, Name: method.GoName,
							InputType:    cleanProtoType(method.Input.GoIdent.GoName, *file.Proto.Package),
							OutputType:   cleanProtoType(method.Output.GoIdent.GoName, *file.Proto.Package),
							StreamOutput: method.Desc.IsStreamingServer(),
							StreamInput:  method.Desc.IsStreamingClient(),
							HttpMethod:   httpMethod,
							HttpPath:     httpPath,
						})
						if err != nil {
							log.Printf("Error: %s", err)
						}
					}
				}
				n := strings.Replace(*file.Proto.Name, ".proto", ".pb.httpclient.go", -1)
				log.Printf("output: %s", n)
				genFile := gen.NewGeneratedFile(n, protogen.GoImportPath(file.GoImportPath))
				if _, err := genFile.Write(text.Bytes()); err != nil {
					return err
				}
				//t := text.String()
				//f := &plugin.CodeGeneratorResponse_File{Name: &n, Content: &t}
				//out = append(out, f)
			}
		}

		/*
			resp := &plugin.CodeGeneratorResponse{File: out}

			buf, err := proto.Marshal(resp)
			if err != nil {
				log.Fatal(err)
			}
			if _, err := os.Stdout.Write(buf); err != nil {
				log.Fatal(err)
			}
		*/
		return nil
	})

}
