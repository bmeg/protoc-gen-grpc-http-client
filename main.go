package main

import (
	"bytes"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/golang/protobuf/proto"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

var CODE_HEADER string = `
// Code generated by protoc-gen-grpc-http-client. DO NOT EDIT.
package {{.Package}}

import (
	"io"
)

// use io module, incase generated sections don't to avoid 'import not used' error
var _ = io.EOF 

`

var CODE_SERVICE string = `
// {{.Service}}HttpClient connects to GRPC http gateway
type {{.Service}}HttpClient struct {
	server string
}

// New{{.Service}}HttpClient creates new {{.Service}}HttpClient
func New{{.Service}}HttpClient(url string) *{{.Service}}HttpClient {
	o := &{{.Service}}HttpClient{server:url}
  	return o
}

`

var CODE_METHOD string = `
func (client *{{.Service}}HttpClient) {{.Name}}(i *{{.InputType}}) (*{{.OutputType}}, error) {
	return nil, nil
}

`

func contains(c []string, a string) bool {
	for _, i := range c {
		if a == i {
			return true
		}
	}
	return false
}

type headerDesc struct {
	Package string
}

type serviceDesc struct {
	Service string
}

type methodDesc struct {
	Package      string
	Service      string
	Name         string
	InputType    string
	OutputType   string
	StreamOutput bool
	StreamInput  bool
}

func cleanProtoType(name string, p string) string {
	if strings.HasPrefix(name, "."+p+".") {
		return name[len(p)+2:]
	}
	return name
}

func boolPtrDefaultFalse(b *bool) bool {
	if b == nil {
		return false
	}
	return *b
}

func main() {
	input, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		log.Printf("failed to read code generator request: %v", err)
		return
	}
	req := new(plugin.CodeGeneratorRequest)
	if err = proto.Unmarshal(input, req); err != nil {
		log.Printf("failed to unmarshal code generator request: %v", err)
		return
	}

	headerTemplate, _ := template.New("header").Parse(CODE_HEADER)
	if err != nil {
		log.Fatal(err)
	}

	serviceTemplate, _ := template.New("service").Parse(CODE_SERVICE)
	methodTemplate, _ := template.New("method").Parse(CODE_METHOD)

	out := []*plugin.CodeGeneratorResponse_File{}
	for _, file := range req.ProtoFile {
		if contains(req.FileToGenerate, *file.Name) {
			//log.Printf("File: %s", *file.Name)
			text := bytes.NewBufferString("")
			headerTemplate.Execute(text, headerDesc{Package: *file.Package})
			for _, service := range file.Service {
				serviceTemplate.Execute(text, serviceDesc{Service: *service.Name})
				log.Printf("Service: %s", *service.Name)
				for _, method := range service.Method {
					log.Printf(" method: %s", method)
					err := methodTemplate.Execute(text, methodDesc{
						Package: *file.Package,
						Service: *service.Name, Name: *method.Name,
						InputType:    cleanProtoType(*method.InputType, *file.Package),
						OutputType:   cleanProtoType(*method.OutputType, *file.Package),
						StreamOutput: boolPtrDefaultFalse(method.ServerStreaming),
						StreamInput:  boolPtrDefaultFalse(method.ClientStreaming),
					})
					if err != nil {
						log.Printf("Error: %s", err)
					}
				}
			}
			n := strings.Replace(*file.Name, ".proto", ".pb.httpclient.go", -1)
			t := text.String()
			f := &plugin.CodeGeneratorResponse_File{Name: &n, Content: &t}
			out = append(out, f)
		}
	}

	resp := &plugin.CodeGeneratorResponse{File: out}

	buf, err := proto.Marshal(resp)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := os.Stdout.Write(buf); err != nil {
		log.Fatal(err)
	}

}
