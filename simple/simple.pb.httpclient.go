// Code generated by protoc-gen-grpc-http-client. DO NOT EDIT.
package simple

import (
	"io"
	"fmt"
	"strings"

	"github.com/go-resty/resty/v2"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/encoding/protojson"

	"github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway/httprule"
	"github.com/grpc-ecosystem/grpc-gateway/utilities"
)

// use io module, incase generated sections don't to avoid 'import not used' error
var _ = io.EOF

func buildPath(temp httprule.Template, msg proto.Message) string {
	var stack []string
	for i := 0; i < len(temp.OpCodes); i += 2 {
		op := utilities.OpCode(temp.OpCodes[i])
		operand := temp.OpCodes[i+1]
		if op == utilities.OpPush {
		} else if op == utilities.OpPushM {
		} else if op == utilities.OpLitPush {
			stack = append(stack, temp.Pool[operand])
		} else if op == utilities.OpConcatN {
			n := operand
			l := len(stack) - n
			stack = append(stack[:l], strings.Join(stack[l:], "/"))
		} else if op == utilities.OpCapture {
			msg.ProtoReflect().Range(func(field protoreflect.FieldDescriptor, val protoreflect.Value) bool {
				if field.JSONName() == temp.Pool[operand] {
					stack = append(stack, val.String())
				}
				return true
			})
		}
	}
	segs := strings.Join(stack, "/")
	if temp.Verb != "" {
		return fmt.Sprintf("/%s:%s", segs, temp.Verb)
	}
	return "/" + segs
}

// GraphInterfaceHttpClient connects to GRPC http gateway
type GraphInterfaceHttpClient struct {
	server string
	client *resty.Client
}

// NewGraphInterfaceHttpClient creates new GraphInterfaceHttpClient
func NewGraphInterfaceHttpClient(url string) *GraphInterfaceHttpClient {
	o := &GraphInterfaceHttpClient{server: url, client: resty.New().SetBaseURL(url)}
	return o
}

func (client *GraphInterfaceHttpClient) AddVertex(i *GraphElement) (*EditResult, error) {
	// StreamingInput: false
	// StreamingOutput: false
	// POST /v1/graph/{graph}/vertex
	//body: vertex

	return nil, nil

}

func (client *GraphInterfaceHttpClient) GetVertex(i *ElementID) (*Vertex, error) {
	// StreamingInput: false
	// StreamingOutput: false
	// GET /v1/graph/{graph}/vertex/{id}

	c, _ := httprule.Parse("/v1/graph/{graph}/vertex/{id}")
	path := buildPath(c.Compile(), i)
	resp, err := client.client.R().Get(path)
	if err != nil {
		return nil, err
	}
	data := resp.Body()
	out := Vertex{}
	err = protojson.Unmarshal(data, &out)
	return &out, err

}

func (client *GraphInterfaceHttpClient) BulkAdd(i *GraphElement) (*BulkEditResult, error) {
	// StreamingInput: true
	// StreamingOutput: false
	// POST /v1/graph
	//body:

	return nil, nil

}

func (client *GraphInterfaceHttpClient) AddGraph(i *GraphID) (*EditResult, error) {
	// StreamingInput: false
	// StreamingOutput: false
	// POST /v1/graph/{graph}
	//body:

	return nil, nil

}

func (client *GraphInterfaceHttpClient) DeleteGraph(i *GraphID) (*EditResult, error) {
	// StreamingInput: false
	// StreamingOutput: false
	// DELETE /v1/graph/{graph}

	c, _ := httprule.Parse("/v1/graph/{graph}")
	path := buildPath(c.Compile(), i)
	resp, err := client.client.R().Delete(path)
	if err != nil {
		return nil, err
	}
	data := resp.Body()
	out := EditResult{}
	err = protojson.Unmarshal(data, &out)
	return &out, err

}

func (client *GraphInterfaceHttpClient) DeleteVertex(i *ElementID) (*EditResult, error) {
	// StreamingInput: false
	// StreamingOutput: false
	// DELETE /v1/graph/{graph}/vertex/{id}

	c, _ := httprule.Parse("/v1/graph/{graph}/vertex/{id}")
	path := buildPath(c.Compile(), i)
	resp, err := client.client.R().Delete(path)
	if err != nil {
		return nil, err
	}
	data := resp.Body()
	out := EditResult{}
	err = protojson.Unmarshal(data, &out)
	return &out, err

}

func (client *GraphInterfaceHttpClient) DeleteIndex(i *IndexID) (*EditResult, error) {
	// StreamingInput: false
	// StreamingOutput: false
	// DELETE /v1/graph/{graph}/index/{label}/{field}

	c, _ := httprule.Parse("/v1/graph/{graph}/index/{label}/{field}")
	path := buildPath(c.Compile(), i)
	resp, err := client.client.R().Delete(path)
	if err != nil {
		return nil, err
	}
	data := resp.Body()
	out := EditResult{}
	err = protojson.Unmarshal(data, &out)
	return &out, err

}

func (client *GraphInterfaceHttpClient) AddSchema(i *Graph) (*EditResult, error) {
	// StreamingInput: false
	// StreamingOutput: false
	// POST /v1/graph/{graph}/schema
	//body: *

	return nil, nil

}
